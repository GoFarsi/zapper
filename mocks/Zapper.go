// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	sentry "github.com/getsentry/sentry-go"
	mock "github.com/stretchr/testify/mock"

	zap "go.uber.org/zap"

	zapper "github.com/GoFarsi/zapper"
)

// Zapper is an autogenerated mock type for the Zapper type
type Zapper struct {
	mock.Mock
}

// DPanic provides a mock function with given fields: _a0
func (_m *Zapper) DPanic(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// DPanicF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) DPanicF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// DPanicW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) DPanicW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// Debug provides a mock function with given fields: _a0
func (_m *Zapper) Debug(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// DebugF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) DebugF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// DebugW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) DebugW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// Error provides a mock function with given fields: _a0
func (_m *Zapper) Error(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// ErrorF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) ErrorF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// ErrorW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) ErrorW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// Fatal provides a mock function with given fields: _a0
func (_m *Zapper) Fatal(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// FatalF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) FatalF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// FatalW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) FatalW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// GetSentryClient provides a mock function with given fields:
func (_m *Zapper) GetSentryClient() *sentry.Client {
	ret := _m.Called()

	var r0 *sentry.Client
	if rf, ok := ret.Get(0).(func() *sentry.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sentry.Client)
		}
	}

	return r0
}

// GetServiceCode provides a mock function with given fields:
func (_m *Zapper) GetServiceCode() uint {
	ret := _m.Called()

	var r0 uint
	if rf, ok := ret.Get(0).(func() uint); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint)
	}

	return r0
}

// GetServiceName provides a mock function with given fields:
func (_m *Zapper) GetServiceName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetZap provides a mock function with given fields:
func (_m *Zapper) GetZap() *zap.Logger {
	ret := _m.Called()

	var r0 *zap.Logger
	if rf, ok := ret.Get(0).(func() *zap.Logger); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*zap.Logger)
		}
	}

	return r0
}

// Info provides a mock function with given fields: _a0
func (_m *Zapper) Info(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// InfoF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) InfoF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// InfoW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) InfoW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// NewCore provides a mock function with given fields: _a0
func (_m *Zapper) NewCore(_a0 ...zapper.Core) error {
	_va := make([]interface{}, len(_a0))
	for _i := range _a0 {
		_va[_i] = _a0[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(...zapper.Core) error); ok {
		r0 = rf(_a0...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Panic provides a mock function with given fields: _a0
func (_m *Zapper) Panic(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// PanicF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) PanicF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// PanicW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) PanicW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// Warn provides a mock function with given fields: _a0
func (_m *Zapper) Warn(_a0 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0...)
	_m.Called(_ca...)
}

// WarnF provides a mock function with given fields: _a0, _a1
func (_m *Zapper) WarnF(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

// WarnW provides a mock function with given fields: _a0, _a1
func (_m *Zapper) WarnW(_a0 string, _a1 ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _a1...)
	_m.Called(_ca...)
}

type mockConstructorTestingTNewZapper interface {
	mock.TestingT
	Cleanup(func())
}

// NewZapper creates a new instance of Zapper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewZapper(t mockConstructorTestingTNewZapper) *Zapper {
	mock := &Zapper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
